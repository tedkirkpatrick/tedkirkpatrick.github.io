<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Iterators: One success story &middot; All my marbles in one place
    
  </title>

  <!-- Google Analytics -->
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66576928-4', 'auto');
  ga('send', 'pageview');
  </script>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Begin Jekyll SEO tag v2.2.3 -->
<meta property="og:title" content="Iterators: One success story" />
<meta name="author" content="Ted Kirkpatrick" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Iterators intrigue me because they seem to bring to C++ facilities that I’ve found congenial in other languages. I’ve spent some time in Haskell and a lot of time in Python, which both support list comprehensions. I’ve also enjoyed the limited amount of C# Language-Integrated Query (LINQ) programming that I’ve done. Yet when I come to actually use the STL iterators, it feels awkward and requires much more text than achieving comparable results using list comprehensions or LINQ. Some of that may be simple unfamiliarity but that is itself a problem: A good design will allow me to apply patterns I’ve learned in other languages." />
<meta property="og:description" content="Iterators intrigue me because they seem to bring to C++ facilities that I’ve found congenial in other languages. I’ve spent some time in Haskell and a lot of time in Python, which both support list comprehensions. I’ve also enjoyed the limited amount of C# Language-Integrated Query (LINQ) programming that I’ve done. Yet when I come to actually use the STL iterators, it feels awkward and requires much more text than achieving comparable results using list comprehensions or LINQ. Some of that may be simple unfamiliarity but that is itself a problem: A good design will allow me to apply patterns I’ve learned in other languages." />
<meta property="og:site_name" content="All my marbles in one place" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-02-21T00:00:00-08:00" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"BlogPosting","headline":"Iterators: One success story","author":{"@type":"Person","name":"Ted Kirkpatrick"},"datePublished":"2017-02-21T00:00:00-08:00","dateModified":"2017-02-21T00:00:00-08:00","description":"Iterators intrigue me because they seem to bring to C++ facilities that I’ve found congenial in other languages. I’ve spent some time in Haskell and a lot of time in Python, which both support list comprehensions. I’ve also enjoyed the limited amount of C# Language-Integrated Query (LINQ) programming that I’ve done. Yet when I come to actually use the STL iterators, it feels awkward and requires much more text than achieving comparable results using list comprehensions or LINQ. Some of that may be simple unfamiliarity but that is itself a problem: A good design will allow me to apply patterns I’ve learned in other languages.","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/02/21/iterators-one-success-story/"},"url":"/2017/02/21/iterators-one-success-story/"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body class="theme-base-0c layout-reverse">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          All my marbles in one place
        </a>
      </h1>
      <p class="lead">A blog about course design, data display, C++, and Python.  Yes, these are related, at least as I see them.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
      
        
          
            <a class="sidebar-nav-item" href="/credits/">Credits</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

    
        <div class="sidebar-tags">
        Tags:<br/>
        
	   
	    <a href="/tag/C++/">C++</a>,
	  
        
	   
	    <a href="/tag/Python/">Python</a>,
	  
        
	  	    
            <a href="/tag/Course design/">Course design</a>
          
        
	</div>
      

    </nav>

    <p>&copy; 2018. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Iterators: One success story</h1>
  <span class="post-date">21 Feb 2017
  
    <span class="tag-block">Tags: 
    
      
      <a href="/tag/C++">C++</a>
      
    
    </span>
  
  </span>
  
  
<p>Iterators intrigue me because they seem to bring to C++ facilities that I’ve found congenial in other languages. I’ve spent some time in Haskell and a lot of time in Python, which both support <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions">list comprehensions</a>. I’ve also enjoyed the limited amount of C# <a href="https://msdn.microsoft.com/en-us/library/bb397933.aspx">Language-Integrated Query (LINQ)</a> programming that I’ve done.</p>

<p>Yet when I come to actually use the STL iterators, it feels awkward and requires much more text than achieving comparable results using list comprehensions or LINQ. Some of that may be simple unfamiliarity but that is itself a problem: A good design will allow me to apply patterns I’ve learned in other languages.</p>

<!--more-->

<p>But it’s more than unfamiliarity.  I’ve practiced implementing functions in the C++ STL and found that simple Python expressions such as</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
</code></pre>
</div>

<p>have to be turned inside-out and sprawl across multiple lines when written in the STL. (I’ll give details in a later post.) The STL appears essentially much more verbose.</p>

<p>I think it’s also significant that, despite the STL’s design being 20 years old, no other mainstream language has adopted it. Deep down, Python’s list comprehensions are in fact constructed from similar mechanisms, <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types">iterator types</a> and <a href="https://docs.python.org/3/glossary.html#term-generator-expression">generator expressions</a>, but the underlying memory management is completely different.</p>

<p>So I want to spend some posts exploring the strengths and weaknesses of STL iterators. And I want to begin with one of its great successes, a success that became available with the <a href="http://en.cppreference.com/w/cpp/language/range-for">range-based <code>for</code></a> feature of C++ 2011.</p>

<h2>A case where iterators work well</h2>

<p>Consider the following C program:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#define LEN 3
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="p">[</span><span class="n">LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">sum</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">a</span><span class="o">+</span><span class="n">LEN</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The loop simply walks a pointer <code>p</code> over the length of array <code>a</code>, summing the values in <code>sum</code>. (Note: The above code is so simple that the optimizer does something much simpler. The Appendix to this post shows the actual code necessary to fake out the optimizer and get the compiler to generate the code I’m describing. I’m displaying the simpler code here because it presents the essential loop.)  The resulting loop code (from gcc 6.2) is as simple as it gets:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  xorl	%eax, %eax
L3:
  addl	(%edx), %eax
  addl	$4, %edx
  cmpl	%esi, %edx
  jne	.L3
</code></pre>
</div>

<p>Register <code>edx</code> is pointer <code>p</code>, incrementing through the array.  Register <code>eax</code> is <code>sum</code>, while register <code>esi</code> contains the address <code>a+LEN</code>. This is the most efficient scalar code possible for the loop (though it could likely be improved by using the x86 <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">vector instructions</a> or your processor’s equivalent).</p>

<p>Here is the same algorithm using the C++ STL library and a range-based <code>for</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;array&gt;
</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
  <span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">a</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>

  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">v</span> <span class="o">:</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>This version generates equivalent loop code (though with different register assignments) as the C program, despite its more abstract presentation.  In fact, C++ will generate equivalent code to C’s pointer-based program for a loop over a <code>std::vector</code> as well:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>

  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">v</span> <span class="o">:</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Where the <code>std::array</code> collection is just mild syntactic sugar over a foundational C/C++ array, a <code>std::vector</code> is a more powerful collection, expanding in size as new elements are appended. Yet a loop over a vector generates just as efficient code as the far more explicit, pointer-oriented code in C.</p>

<p>Iterators link the STL collections and ranged for (and all the algorithms in the <a href="http://en.cppreference.com/w/cpp/algorithm">algorithms library</a>).  A collection provides a suite of iterators according to a standardized interface and the ranged for simply calls those iterators. Template specialization allows the library to specify efficient, pointer-based iteration over collections for which that makes sense.</p>

<p>This is a real benefit of STL iterators: We specify an abstract interface to every STL collection and for those collections represented by a contiguous block of elements, such as <code>std::array</code> or <code>std::vector</code>, we get code every bit as efficient as the best that we can get from any language. For collections based on non-contiguous representations, such as <code>std::map</code> or <code>std::unordered_map</code>, the same ranged-for can be used but will generate the more complex traversal code required for a binary tree or hash table, respectively.</p>

<p>Once we have iterators, a tweak to the concrete syntax of the core language provided a concise form for iterating over a collection, the ranged <code>for</code>. This loop is more robust than the C <code>for</code> loop, as the start and end points of the loop are generated by the collection.  By contrast, the C loop (and the pre-2011 <code>for</code> loop in C++) requires us to correctly specify the end point of the array, with no provision for the compiler to cross-check.</p>

<p>This is an unequivocal win for the iterator design. In future posts, I’ll consider functional requirements where it becomes far less successful.</p>

<h2>Appendix</h2>

<p>The C program given above in fact generates the following object code:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  .cfi_startproc
  movl	$15, %eax
  ret
  .cfi_endproc
</code></pre>
</div>

<p>The smarty-pants optimizer has recognized that the loop is completely specified and has precomputed its result (the value 15) at compile-time.  To generate an actual runtime loop, we have to make the array larger and read it from input:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="cp">#define LEN 10
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="p">[</span><span class="n">LEN</span><span class="p">];</span>

  <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">scanf</span> <span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

  <span class="kt">int</span> <span class="n">sum</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">a</span><span class="o">+</span><span class="n">LEN</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The resulting loop generates the code given in the body of this post.</p>

<p>A similar problem arises with the C++ code. Here is the version that prevents the optimizer from eliminating the loop:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;array&gt;
#include &lt;iostream&gt;
</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
  <span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">10</span><span class="o">&gt;</span> <span class="n">a</span> <span class="p">{};</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">:</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">v</span> <span class="o">:</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>


</div>




    </div>

  </body>
</html>
