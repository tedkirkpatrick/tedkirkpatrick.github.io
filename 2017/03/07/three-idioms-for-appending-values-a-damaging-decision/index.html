<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="description" content="Blog for A. E. Kirkpatrick and  Kirkpatrick Computing Services">
  <meta name="author" content="Arthur E. Kirkpatrick">
  <meta name="copyright" content="Arthur E. Kirkpatrick, 2018">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Three idioms for appending values&mdash;a damaging decision? &middot; All my marbles in one place
    
  </title>

  <!-- Google Analytics -->
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66576928-4', 'auto');
  ga('send', 'pageview');
  </script>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Begin Jekyll SEO tag v2.2.3 -->
<meta property="og:title" content="Three idioms for appending values—a damaging decision?" />
<meta name="author" content="Ted Kirkpatrick" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Update: See also the next post, which adds a fourth idiom and mitigates some of the criticisms in the conclusion of this post. The STL code for squaring the positive values, included the following lines to create the intermediate result t1 containing the positive values of the original list a:" />
<meta property="og:description" content="Update: See also the next post, which adds a fourth idiom and mitigates some of the criticisms in the conclusion of this post. The STL code for squaring the positive values, included the following lines to create the intermediate result t1 containing the positive values of the original list a:" />
<meta property="og:site_name" content="All my marbles in one place" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-03-07T00:00:00-08:00" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"BlogPosting","headline":"Three idioms for appending values—a damaging decision?","author":{"@type":"Person","name":"Ted Kirkpatrick"},"datePublished":"2017-03-07T00:00:00-08:00","dateModified":"2017-03-07T00:00:00-08:00","description":"Update: See also the next post, which adds a fourth idiom and mitigates some of the criticisms in the conclusion of this post. The STL code for squaring the positive values, included the following lines to create the intermediate result t1 containing the positive values of the original list a:","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/03/07/three-idioms-for-appending-values-a-damaging-decision/"},"url":"/2017/03/07/three-idioms-for-appending-values-a-damaging-decision/"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body class="theme-base-0c layout-reverse">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          All my marbles in one place
        </a>
      </h1>
      <p class="lead">A blog about course design, data display, C++, and Python.  Yes, these are related, at least as I see them.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
      
        
          
            <a class="sidebar-nav-item" href="/comment-policy/">Comment policy</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/credits/">Credits</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

    
        <div class="sidebar-tags">
        Tags:<br/>
        
	   
	    <a href="/tag/C++/">C++</a>,
	  
        
	   
	    <a href="/tag/Python/">Python</a>,
	  
        
	   
	    <a href="/tag/Course design/">Course design</a>,
	  
        
	   
	    <a href="/tag/Soft skills/">Soft skills</a>,
	  
        
	   
	    <a href="/tag/Statistics/">Statistics</a>,
	  
        
	   
	    <a href="/tag/Experimental design/">Experimental design</a>,
	  
        
	   
	    <a href="/tag/Rhetoric/">Rhetoric</a>,
	  
        
	  	    
            <a href="/tag/Admin/">Admin</a>
          
        
	</div>
      

    </nav>

    <p>&copy; 2018. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Three idioms for appending values&mdash;a damaging decision?</h1>
  <span class="post-date">07 Mar 2017
  
    <span class="tag-block">Tags: 
    
      
      <a href="/tag/C++">C++</a>
      
    
    </span>
  
  </span>
  
  <p><b>Update:</b> See also the <a href="/2017/03/09/a-simpler-fourth-idiom-for-appending/">next post</a>, which adds a fourth idiom and mitigates some of the criticisms in the conclusion of this post.</p>

<p>The <a href="/2017/02/22/iterators-a-failure-case/">STL code for squaring the positive values</a>, included the following lines to create the intermediate result <code>t1</code> containing the positive values of the original list <code>a</code>:</p>

<!--more-->
<!-- highlight="1,4" -->
<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t1</span> <span class="p">{};</span>
<span class="n">copy_if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span>
         <span class="n">a</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span>
         <span class="n">back_inserter</span><span class="p">(</span><span class="n">t1</span><span class="p">),</span>
         <span class="p">[](</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
</code></pre>
</div>

<p>This is a typical idiom when writing sequences of STL transformations. It declares an empty vector in Line 1 then appends new values to it via a <a href="http://en.cppreference.com/w/cpp/iterator/back_inserter"><code>back_inserter()</code></a> adaptor (Line 4).</p>

<p>As an idiom, this works well. It fits the STL pattern for algorithms</p>

<div class="highlighter-rouge"><pre class="highlight"><code>algorithm (start, end, sink [, other options])
</code></pre>
</div>

<p>that we use in the sequence and the <code>back_inserter()</code> adapter can be applied to a <code>std::vector</code>, <code>std::deque</code>, or <code>std::list</code>. But the idiom also has some problems:  For some kinds of objects, it may waste a lot of CPU time on unnecessary operations. It can also fragment the heap.</p>

<p>There are in fact three distinct idioms that you might use to build the temporary result, of increasing efficiency. Unfortunately, the most efficient idiom does not fit the above pattern for using the STL algorithms. Instead, the programmer must construct their algorithm from a <code>for</code> loop and basic code. As of C++ 2017, There is no way in the Standard Library to combine the standard algorithms with the most efficient idiom for constructing results.</p>

<h2>Allocation, initialization, and assignment</h2>

<p>To understand the different idioms for building a result in a collection, we have to first distinguish storage duration and variable lifetime. As I mentioned several posts ago, I am planning a whole series on how C++ approaches these topics, differentiating that approach from the ones taken by managed languages. I don’t need to go into as much detail for this post, so I’ll focus the discussion on the specific points necessary to describe the stages for values being appended to STL collections.</p>

<p>C++ carefully distinguishes the storage management from the object life cycle. Storage management has two steps and is performed <em>by the collection</em> as its capacity requirements expand and contract:</p>

<dl>
<dt>Allocation</dt>
<dd>A block of raw, uninitialized bytes is reserved by the collection, typically from the C++ runtime via <a href="http://en.cppreference.com/w/cpp/memory/new/operator_new">operator <code>new()</code></a>.  The C++ runtime in turn requests large blocks of memory from the operating system. 
</dd>
<dt>Deallocation</dt>
<dd>A block of previously-allocated bytes is returned, typically to the C++ runtime via <a href="http://en.cppreference.com/w/cpp/memory/new/operator_delete">operator <code>delete()</code></a>. The runtime typically retains the storage for potential reallocation, returning it to the operating system when the application terminates.
</dd>
</dl>

<p>Allocation and deallocation deal simply in raw bytes that have no meaning in the language. Only object values have meaning. Values appended to a collection have a distinct life cycle, with steps occurring in the following order:</p>

<dl>
<dt>Initialization</dt>
<dd>When a value is appended to the collection it is built in storage that has been allocated by the collection but not yet used to store a value.  The value is built by the constructor for the object's class.
</dd>
<dt>Assignment</dt>
<dd>If the value can be accessed via a non-<code>const</code> type, it may be overwritten via an assignment.
</dd>
<dt>Destruction</dt>
<dd>When the collection is destroyed, it destroys all the values it holds, calling the destructor for each value.  The value destructor in turn releases any resources that value holds.
</dd>
</dl>

<p>This simple model is sufficient to describe the case of interest here, where values are appended to a collection in a single pass, perhaps to be read back as input in a subsequent pass. More complicated uses, such as erasing objects from a collection, require a more sophisticated description.</p>

<h2>A class with a transparent life cycle</h2>

<p>To compare the different idioms for appending results, we need to make the above stages visible.  The following class instruments its member functions to print a message whenever an instance is created, assigned, or deleted:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">C</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">m1</span> <span class="p">{</span><span class="n">a</span><span class="p">},</span> <span class="n">m2</span><span class="p">{</span><span class="n">b</span><span class="p">}</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Basic constructor for "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">C</span> <span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">m1</span> <span class="p">{</span><span class="n">c</span><span class="p">.</span><span class="n">m1</span><span class="p">},</span> <span class="n">m2</span> <span class="p">{</span><span class="n">c</span><span class="p">.</span><span class="n">m2</span><span class="p">}</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy constructor for "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" from "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Replace above with this to test with only move constructor
</span>  <span class="c1">//C (const C&amp; c) = delete;
</span>
  <span class="n">C</span> <span class="p">(</span><span class="n">C</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">m1</span> <span class="p">{</span><span class="n">c</span><span class="p">.</span><span class="n">m1</span><span class="p">},</span> <span class="n">m2</span> <span class="p">{</span><span class="n">c</span><span class="p">.</span><span class="n">m2</span><span class="p">}</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Move constructor for "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" from "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">C</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Default constructor for "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">C</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy assignment for "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" from "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">m1</span><span class="p">;</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">m2</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">C</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="n">C</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Move assignment for "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" from "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">m1</span><span class="p">;</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">m2</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">C</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Destructor for "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">temps_del</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">m1</span> <span class="p">{};</span>
  <span class="kt">int</span> <span class="n">m2</span> <span class="p">{};</span>
<span class="p">};</span>
</code></pre>
</div>

<p>The class simply stores two integers, <code>m1</code> and <code>m2</code>.  Its member functions call instrumentation functions <code>collection_name()</code> and <code>temp_del</code>, which track details of the allocations.  The full code for this post, including instrumentation, is presented in the appendix.</p>

<p>Let’s see what happens when we use different idioms to append instances of this class to a <code>std::vector</code>.</p>

<h2>Incremental append: Multiple allocations, multiple per-item operations</h2>

<p>Consider a simple case where we want to use a vector <code>init</code> containing the integers 0 through 4, inclusive, to build a <code>vector</code>, using the <code>back_inserter()</code> approach:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">c1</span> <span class="p">{};</span>
<span class="n">transform</span> <span class="p">(</span><span class="n">init</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">init</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">c1</span><span class="p">),</span>
           <span class="p">[]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">});</span>
</code></pre>
</div>

<p>Here is an annotated sequence of the constructions, copies, and destructions required to append the five instances of <code>C</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>New collection c1
// Append C(0, 0)
Basic constructor for T0
[vector allocates space for C value, c1[0]]
Move constructor for c1[0] from T0
Destructor for T0

// Append C(1, 1)
Basic constructor for T0
[Vector allocates space for C values, c1[0]' to c1[1]']
Move constructor for c1[1]' from T0
Copy constructor for c1[0]' from c1[0]
Destructor for c1[0]
Destructor for T0
[Space for c1[0] deallocated]

// Append C(2, 2)
Basic constructor for T0
[Vector allocates space for C values, c1[0]'' to c[3]'']
Move constructor for c1[2]'' from T0
Copy constructor for c1[0]'' from c1[0]'
Copy constructor for c1[1]'' from c1[1]'
Destructor for c1[0]'
Destructor for c1[1]'
[Space for c1[0]' to c1[1]' deallocated]
Destructor for T0

// Append C(3, 3)
Basic constructor for T0
Move constructor for c1[3]'' from T0
Destructor for T0

// Append C(4, 4)
Basic constructor for T0
[Vector allocates space for C values, c1[0]''' to c1[4]''']
Move constructor for c1[4]''' from T0
Copy constructor for c1[0]''' from c1[0]''
Copy constructor for c1[1]''' from c1[1]''
Copy constructor for c1[2]''' from c1[2]''
Copy constructor for c1[3]''' from c1[3]''
Destructor for c1[0]''
Destructor for c1[1]''
Destructor for c1[2]''
Destructor for c1[3]''
[Space for c1[0]'' to c1[3]'' deallocated]
Destructor for T0
</code></pre>
</div>

<p>Whoa!  That’s a lot of action. Every append requires creating a temporary <code>C</code> value, <code>T0</code>, which is destroyed once the append has completed. The vector allocates four progressively larger blocks (enough for 1 C value, 2 C values, 4 C values, and a final block at least 5 C values large) as its required capacity grows. Each time it expands, it copies the old values into the new block, then destroys the originals and deallocates the old block. For this class, the constructors, copies, and destructors are efficient, but they might require substantial CPU time for larger classes. And for any class size, the allocation / deallocation pairs contribute to memory fragmentation. Can we do better?</p>

<h2>Initialize and assign: Single allocation, two per-item constructions</h2>

<p>The first idiom required multiple allocations and deletions because we built the vector an item at a time, expanding as more values were added. Given that the number of items of the result will be exactly the number in <code>init</code>, we could initialize the result vector to its full length and then build the new values there. When we construct the initial vector of five values, however, it will construct default values for every entry. When we build the result, we will be overwriting those default values with an assignment. Here is the code:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">c2</span> <span class="p">(</span><span class="n">init</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="k">auto</span> <span class="n">c2_it</span> <span class="o">=</span> <span class="n">c2</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">in_it</span> <span class="o">=</span> <span class="n">init</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="n">in_it</span> <span class="o">!=</span> <span class="n">init</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span> <span class="o">++</span><span class="n">in_it</span><span class="p">,</span> <span class="o">++</span><span class="n">c2_it</span><span class="p">)</span>
  <span class="o">*</span><span class="n">c2_it</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="o">*</span><span class="n">in_it</span><span class="p">,</span> <span class="o">*</span><span class="n">in_it</span><span class="p">);</span>
</code></pre>
</div>

<p>The algorithm needs to maintain two iterators, one each for the source <code>init</code> and the sink <code>c2</code>, so I chose a <code>for</code> loop rather than the <code>std::copy</code> algorithm. With some effort, you could build a custom assign-to-the-end-iterator and use <code>std::copy</code>.</p>

<p>Here’s the resulting operation sequence:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[Vector allocates space for at least 5 values, c2[0] to c2[4]]
Default constructor for c2[0]
Default constructor for c2[1]
Default constructor for c2[2]
Default constructor for c2[3]
Default constructor for c2[4]
New collection c2 // The collection is now initialized

// Append C(0, 0)
Basic constructor for T0
Move assignment for c2[0] from T0
Destructor for T0

// Append C(1, 1)
Basic constructor for T0
Move assignment for c2[1] from T0
Destructor for T0

// Append C(2, 2)
Basic constructor for T0
Move assignment for c2[2] from T0
Destructor for T0

// Append C(3, 3)
Basic constructor for T0
Move assignment for c2[3] from T0
Destructor for T0

// Append C(4, 4)
Basic constructor for T0
Move assignment for c2[4] from T0
Destructor for T0
</code></pre>
</div>

<p>This idiom requires substantially fewer operations on <code>C</code> values and has exactly one allocation, of exactly the required size. Because we’re assigning an <a href="http://en.cppreference.com/w/cpp/language/value_category">r-value</a> in Line 4 and class <code>C</code> includes a <a href="http://en.cppreference.com/w/cpp/language/move_assignment">move assignment </a> member, move assignment is used. For this class whose members are all <code>int</code>s, there is no performance improvement from move assignment, but it might be much more efficient for instances of a class that owns resources such as dynamic memory.</p>

<p>This looks like a win, overall. We’ve saved a lot of operations and used the bare minimum of allocations. The “extra” operations left, construction of a default value and move assignment, are both typically fast. The only downside is that we have to maintain two iterators, using a more complex <code>for</code> or a custom adaptor to subsume the iterator. Is there a way we can do even better?</p>

<h2>Reserve and emplace: Single allocation, single per-item construction</h2>

<p>The remaining inefficiency in the second idiom is that we construct a sequence of default values that we never need and will overwrite as soon as the collection is ready. What we really want to do is simpler than that: Have the collection allocate all the storage we need and then construct our values directly in that storage.</p>

<p>This approach became viable in 2011 with the addition of <em>emplace members</em> to the STL collections (this feature in turn was enabled by the C++ 2011 core language addition of <a href="http://en.cppreference.com/w/cpp/language/parameter_pack">template parameter packs</a>). In particular, the<code class="highlighter-rouge"> emplace_back()</code> member constructs a value directly after the last value in the collection. If there is allocated space available after the last value, the appended value is simply constructed there, but if the vector is full, the same allocate-copy-deallocate sequence as the first method must be used.</p>

<p>This suggests the following pattern:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>reserve space in the vector sufficient to hold all items
build the items using emplace_back()
</code></pre>
</div>

<p>In C++:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">c3</span> <span class="p">{};</span>
<span class="n">c3</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">init</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">v</span> <span class="o">:</span> <span class="n">init</span><span class="p">)</span>
  <span class="n">c3</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</code></pre>
</div>

<p>Once again, rather than build a custom iterator, I have used a <code>for</code> loop to iterate over the source and used <code>emplace_back()</code> in the loop body to append to the sink. Here’s the operations this code produces:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>New collection c3
[Vector allocates space for at least 5 values, c3[0] to c3[4]]
Basic constructor for c3[0]
Basic constructor for c3[1]
Basic constructor for c3[2]
Basic constructor for c3[3]
Basic constructor for c3[4]
</code></pre>
</div>

<p>Using <code>emplace_back()</code>, we have built the result using the minimum number of allocations and operations on the <code>C</code> values. In tradeoff, we can no longer use simple STL algorithms unless we use some form of  <code>back_emplacer</code> adaptor. Although none is provided in the 2017 STL, Andre Tomazos has <a href="http://stackoverflow.com/questions/18728257/back-emplacer-implementation-default-operator-vs-universal-reference-version">presented a solution</a> in a Stack Overflow discussion.</p>

<h2>Explicit storage management increases programmer load</h2>

<p>The current version of the STL forces programmers to make a Faustian choice when implementing list comprehension-style algorithms: Use the simple, well-supported longstanding approach and accept potential inefficiencies, or use the more recent emplace members, gaining efficiency at some cost in code complexity.  The biggest cost of all of this is the decision itself. Where the Python or Haskell programmer simply specifies list operations, the C++ programmer must stop for every sink, whether an intermediate result or the final value, and choose an append idiom.</p>

<p>As I noted in an earlier post, it is not clear to me that good modern compilers, whether static or just-in-time, cannot produce equally efficient code from list comprehensions as a C++ compiler produces from the more complex STL approach. I have the sad suspicion that this is a case where C++’s emphasis on explicit storage management increases programmer load for little to no efficiency benefit.</p>

<h2>Appendix: Full source</h2>

<p>Here is the full source from which the annotated operation displays were produced. The instrumentation code is just functional enough to produce useful results with one specific compiler and library release. It is far from general code. Specific caveats about the instrumentation code:</p>

<ul>
<li>The actual output from this code is more raw than the annotated versions given above. I derived the presentation versions from the output of this code.
</li>
<li>The <code>is_stack()</code> function is highly specific to the implementation and specific runtime options such as stack size. It is nothing close to general production use.
</li>
<li>The instrumentation functions call <code>std::vector::data()</code> during updates to the vector. The function's behaviour in such cases is undefined. For this compiler and library version, it returned the address of the old allocation. In other circumstances, it might behave differently.
</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/*
  Demonstration of different approaches to building a vector.
 */</span>

<span class="cp">#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
</span>
<span class="cp">#include &lt;experimental/iterator&gt;
</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">generate</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>

<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">make_ostream_joiner</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">temps_del</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">*</span> <span class="n">cp</span><span class="p">);</span>
<span class="n">string</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">*</span> <span class="n">loc</span><span class="p">);</span>

<span class="cm">/*
  Class to make creation, assignment, and destruction visible.
 */</span>
<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">C</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">m1</span> <span class="p">{</span><span class="n">a</span><span class="p">},</span> <span class="n">m2</span><span class="p">{</span><span class="n">b</span><span class="p">}</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Basic constructor for "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">C</span> <span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">m1</span> <span class="p">{</span><span class="n">c</span><span class="p">.</span><span class="n">m1</span><span class="p">},</span> <span class="n">m2</span> <span class="p">{</span><span class="n">c</span><span class="p">.</span><span class="n">m2</span><span class="p">}</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy constructor for "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" from "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Replace above with this to test with only move constructor
</span>  <span class="c1">//C (const C&amp; c) = delete;
</span>
  <span class="n">C</span> <span class="p">(</span><span class="n">C</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">m1</span> <span class="p">{</span><span class="n">c</span><span class="p">.</span><span class="n">m1</span><span class="p">},</span> <span class="n">m2</span> <span class="p">{</span><span class="n">c</span><span class="p">.</span><span class="n">m2</span><span class="p">}</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Move constructor for "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" from "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">C</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Default constructor for "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">C</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy assignment for "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" from "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">m1</span><span class="p">;</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">m2</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">C</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="n">C</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Move assignment for "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" from "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">m1</span><span class="p">;</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">m2</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">C</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Destructor for "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">collection_name</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">temps_del</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">m1</span> <span class="p">{};</span>
  <span class="kt">int</span> <span class="n">m2</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"C ("</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">m1</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">m2</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">using</span> <span class="n">Coll</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">;</span>

<span class="cm">/*
  Instrumentation to attribute locations to owning collection.
  One-off code---specific to this demonstration and tool chain.
 */</span>
<span class="n">string</span> <span class="nf">to_string</span><span class="p">(</span><span class="kt">void</span> <span class="k">const</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ostringstream</span> <span class="n">os</span> <span class="p">{};</span>
  <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">os</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Cpair</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">Coll</span><span class="o">*</span> <span class="n">cp</span> <span class="p">{};</span>
  <span class="k">const</span> <span class="n">string</span> <span class="n">name</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">Cpair</span><span class="o">&gt;</span> <span class="n">colls</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="n">Tpair</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">C</span><span class="o">*</span> <span class="n">cp</span> <span class="p">{};</span>
  <span class="n">string</span> <span class="n">name</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">Tpair</span><span class="o">&gt;</span> <span class="n">temps</span> <span class="p">{};</span>

<span class="k">auto</span> <span class="nf">temps_find</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">*</span> <span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">find_if</span><span class="p">(</span><span class="n">temps</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">temps</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
		 <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">auto</span> <span class="n">tp</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">tp</span><span class="p">.</span><span class="n">cp</span> <span class="o">==</span> <span class="n">cp</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">colls_add</span><span class="p">(</span><span class="k">const</span> <span class="n">Coll</span><span class="o">*</span> <span class="n">coll</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">colls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpair</span> <span class="p">{</span><span class="n">coll</span><span class="p">,</span> <span class="n">name</span><span class="p">});</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"New collection "</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">", base "</span> <span class="o">&lt;&lt;</span> <span class="n">coll</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">temps_add</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">*</span> <span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">temps_find</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">temps</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="n">temps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Tpair</span><span class="p">{</span><span class="n">cp</span><span class="p">,</span> <span class="n">name</span><span class="p">});</span>
<span class="p">}</span>

<span class="cm">/*
  Highly specific to implementation, memory model, and so forth!
 */</span>
<span class="n">bool</span> <span class="nf">is_stack</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">*</span> <span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0x700'000'000'000UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">temps_del</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">*</span> <span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">is_stack</span><span class="p">(</span><span class="n">cp</span><span class="p">))</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">temps_find</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">temps</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">temps</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">string</span> <span class="nf">temps_name</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">*</span> <span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">temps_find</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">temps</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_stack</span><span class="p">(</span><span class="n">cp</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="s">"T"</span><span class="p">)</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">temps</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
      <span class="n">temps_add</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">nm</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">to_string</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">string</span> <span class="nf">collection_name</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">*</span> <span class="n">loc</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">cp</span> <span class="o">:</span> <span class="n">colls</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">base</span> <span class="o">=</span> <span class="n">cp</span><span class="p">.</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&lt;=</span> <span class="n">loc</span> <span class="o">&amp;&amp;</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">base</span><span class="o">+</span><span class="n">cp</span><span class="p">.</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">())</span>
      <span class="k">return</span> <span class="n">cp</span><span class="p">.</span><span class="n">name</span> <span class="o">+</span><span class="s">"["</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">loc</span><span class="o">-</span><span class="n">base</span><span class="p">)</span> <span class="o">+</span><span class="s">"]"</span> <span class="o">+</span>
	<span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="n">base</span> <span class="o">?</span> <span class="n">string</span><span class="p">(</span><span class="s">" ["</span><span class="p">)</span><span class="o">+</span><span class="n">to_string</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span><span class="o">+</span><span class="n">string</span><span class="p">(</span><span class="s">"]"</span><span class="p">)</span> <span class="o">:</span> <span class="n">string</span><span class="p">(</span><span class="s">""</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">temps_name</span><span class="p">(</span><span class="n">loc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*
  Demonstrate three ways to build a result vector.
 */</span>
<span class="n">constexpr</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">init</span> <span class="p">(</span><span class="n">len</span><span class="p">);</span>
  <span class="n">generate</span><span class="p">(</span><span class="n">init</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">init</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">]</span> <span class="p">()</span> <span class="k">mutable</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="p">});</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Source vector: "</span><span class="p">;</span>
  <span class="n">copy</span> <span class="p">(</span><span class="n">init</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">init</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">make_ostream_joiner</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">", "</span><span class="p">));</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Default vector, back_inserter:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">Coll</span> <span class="n">c1</span> <span class="p">{};</span>
  <span class="n">colls_add</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">c1</span><span class="p">,</span> <span class="s">"c1"</span><span class="p">);</span>
  <span class="n">transform</span> <span class="p">(</span><span class="n">init</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">init</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">c1</span><span class="p">),</span>
	     <span class="p">[]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">});</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Result: "</span><span class="p">;</span>
  <span class="n">copy</span> <span class="p">(</span><span class="n">c1</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">c1</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">make_ostream_joiner</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">", "</span><span class="p">));</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Default values of required length, assigned</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">Coll</span> <span class="n">c2</span> <span class="p">(</span><span class="n">init</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">colls_add</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">c2</span><span class="p">,</span> <span class="s">"c2"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">c2_it</span> <span class="o">=</span> <span class="n">c2</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">in_it</span> <span class="o">=</span> <span class="n">init</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="n">in_it</span> <span class="o">!=</span> <span class="n">init</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span> <span class="o">++</span><span class="n">in_it</span><span class="p">,</span> <span class="o">++</span><span class="n">c2_it</span><span class="p">)</span>
    <span class="o">*</span><span class="n">c2_it</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="o">*</span><span class="n">in_it</span><span class="p">,</span> <span class="o">*</span><span class="n">in_it</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Result: "</span><span class="p">;</span>
  <span class="n">copy</span> <span class="p">(</span><span class="n">c2</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">c2</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">make_ostream_joiner</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">", "</span><span class="p">));</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Reserved vector, emplace_back</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">Coll</span> <span class="n">c3</span> <span class="p">{};</span>
  <span class="n">colls_add</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">c3</span><span class="p">,</span> <span class="s">"c3"</span><span class="p">);</span>
  <span class="n">c3</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">init</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">v</span> <span class="o">:</span> <span class="n">init</span><span class="p">)</span>
    <span class="n">c3</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Result: "</span><span class="p">;</span>
  <span class="n">copy</span> <span class="p">(</span><span class="n">c3</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">c3</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">make_ostream_joiner</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">", "</span><span class="p">));</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Destructors called as collections go out of scope:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>


</div>




<div id="disqus_thread"></div>
<script>

var disqus_config = function () {
this.page.url = "http://kirkpatricktech.com/2017/03/07/three-idioms-for-appending-values-a-damaging-decision/";
//this.page.identifier = "/2017/03/07/three-idioms-for-appending-values-a-damaging-decision";
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://kirkpatricktech-com.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </div>

  </body>
</html>
