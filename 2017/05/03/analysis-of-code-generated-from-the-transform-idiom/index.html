<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="description" content="Blog for A. E. Kirkpatrick and  Kirkpatrick Computing Services">
  <meta name="author" content="Arthur E. Kirkpatrick">
  <meta name="copyright" content="Arthur E. Kirkpatrick, 2018">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Analysis of code generated from the transform idiom &middot; All my marbles in one place
    
  </title>

  <!-- Google Analytics -->
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66576928-4', 'auto');
  ga('send', 'pageview');
  </script>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Begin Jekyll SEO tag v2.2.3 -->
<meta property="og:title" content="Analysis of code generated from the transform idiom" />
<meta name="author" content="Ted Kirkpatrick" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The last post presented the baseline C++ code and its generated machine code. Now it’s time to compare the code generated by the std::transform idiom and see how well it fares." />
<meta property="og:description" content="The last post presented the baseline C++ code and its generated machine code. Now it’s time to compare the code generated by the std::transform idiom and see how well it fares." />
<meta property="og:site_name" content="All my marbles in one place" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-05-03T00:00:00-07:00" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"BlogPosting","headline":"Analysis of code generated from the transform idiom","author":{"@type":"Person","name":"Ted Kirkpatrick"},"datePublished":"2017-05-03T00:00:00-07:00","dateModified":"2017-05-03T00:00:00-07:00","description":"The last post presented the baseline C++ code and its generated machine code. Now it’s time to compare the code generated by the std::transform idiom and see how well it fares.","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/05/03/analysis-of-code-generated-from-the-transform-idiom/"},"url":"/2017/05/03/analysis-of-code-generated-from-the-transform-idiom/"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body class="theme-base-0c layout-reverse">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          All my marbles in one place
        </a>
      </h1>
      <p class="lead">A blog about course design, data display, C++, and Python.  Yes, these are related, at least as I see them.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
      
        
          
            <a class="sidebar-nav-item" href="/comment-policy/">Comment policy</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/credits/">Credits</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

    
        <div class="sidebar-tags">
        Tags:<br/>
        
	   
	    <a href="/tag/C++/">C++</a>,
	  
        
	   
	    <a href="/tag/Python/">Python</a>,
	  
        
	   
	    <a href="/tag/Course design/">Course design</a>,
	  
        
	   
	    <a href="/tag/Big data/">Big data</a>,
	  
        
	   
	    <a href="/tag/Soft skills/">Soft skills</a>,
	  
        
	   
	    <a href="/tag/Statistics/">Statistics</a>,
	  
        
	   
	    <a href="/tag/Experimental design/">Experimental design</a>,
	  
        
	   
	    <a href="/tag/Rhetoric/">Rhetoric</a>,
	  
        
	   
	    <a href="/tag/Admin/">Admin</a>,
	  
        
	  	    
            <a href="/tag/Distributed systems/">Distributed systems</a>
          
        
	</div>
      

    </nav>

    <p>&copy; 2019. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Analysis of code generated from the transform idiom</h1>
  <span class="post-date">03 May 2017
  
    <span class="tag-block">Tags: 
    
      
      <a href="/tag/C++">C++</a>
      
    
    </span>
  
  </span>
  
  <p>The last post presented the baseline C++ code and its generated machine code. Now it’s time to compare the code generated by the <code class="highlighter-rouge">std::transform</code> idiom and see how well it fares.</p>

<h2>Removing two inefficiencies</h2>

<p>I’m going to analyze a slightly improved version of the <code class="highlighter-rouge">transform</code> idiom. When I examined the code generated by the <a href="/2017/03/26/a-single-stl-statement-equivalent-to-the-basic-python-list-comprehension/">version I presented originally</a>, I saw two simple inefficiencies I’d left in, two rookie errors:</p>
<ol>
<li>The lambda parameter `p` is passed by copy rather than by reference, constructing a new string, including a heap allocation, for every invocation.
</li>
<li>The `string("us")` expression inside the lambda filter inserted a conversion from `char const *` to `std::string` for every invocation, just to create a constant string.
</li>
</ol>

<p>I improved the code by eliminating these conversions from the loop. I eliminated the first by simply passing the lambda parameter by-reference.</p>

<p>I could not eliminate the second conversion altogether, so I moved it outside the <code class="highlighter-rouge">transform</code> call, declaring <code class="highlighter-rouge">const string us</code> and then capturing it by-copy in the lambda call.</p>

<p>Here is the revised code with the revised lines highlighted:</p>

<!-- highlight="5,8,9"-->
<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">using</span> <span class="n">ppair</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">oppair</span> <span class="o">=</span> <span class="n">optional</span><span class="o">&lt;</span><span class="n">ppair</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">plist</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ppair</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">const</span> <span class="n">string</span> <span class="n">us</span> <span class="o">=</span> <span class="s">"US"</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">opt_back_inserter</span><span class="p">(</span><span class="n">res</span><span class="p">),</span>
  <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">us</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">oppair</span><span class="p">();</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">oppair</span><span class="p">(</span><span class="n">ppair</span><span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">});</span>
  <span class="p">}</span> <span class="p">);</span>
</code></pre>
</div>

<p>The copy-capture of <code class="highlighter-rouge">us</code> in the lambda expression only generates a single copy-constructor call. The above code compiles to something like:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span>
  <span class="k">struct</span> <span class="n">lambda_type</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">l_us</span><span class="p">;</span>
    <span class="n">lambda_type</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">us</span><span class="p">)</span> <span class="n">l_us</span><span class="p">(</span><span class="n">us</span><span class="p">)</span> <span class="p">{};</span>
    <span class="n">ppair</span> <span class="nf">operator</span> <span class="p">(</span><span class="n">ppair</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="n">l_us</span> <span class="p">...</span>  <span class="p">};</span>
  <span class="p">};</span>
  <span class="n">lambda_type</span> <span class="n">lambda</span> <span class="p">{</span><span class="n">us</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(...,</span> <span class="n">lambda</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The member variable <code class="highlighter-rouge">l_us</code> is constructed once, <em>before</em> the call to <code class="highlighter-rouge">transform</code>, then its destructor is called immediately following.  The calls to <code class="highlighter-rouge">lambda_type::operator(ppair&amp; p)</code> inside <code class="highlighter-rouge">transform</code> are efficient references to a local variable, internally represented as offsets <code class="highlighter-rouge">0x80–0x9f</code> from the stack pointer <code class="highlighter-rouge">%rsp</code> in the machine code. The extra <code class="highlighter-rouge">l_us</code> variable does increase the stack requirements by 32 bytes, though.</p>

<h2>Machine code generated by the more efficient version</h2>

<p>With those changes made, the <code class="highlighter-rouge">transform</code> call is compiled to the following machine code (again, gcc 6.2 with <code class="highlighter-rouge">libstdc++</code>, compiled with <code class="highlighter-rouge">-O2</code>, as disassembled by gdb).  It’s a bit of a slog, so just glance at it and I’ll see you on the other side:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// LOOP
// 941 - 600 = 341 bytes (6-7 instruction cache lines)
//         PLUS 69 bytes in outside branch targets (2 instruction cache lines)
//           = 410 bytes (8-9 instruction cache lines)

// Register usage
// %rax == res_i (for most of the loop body, lines +721 to end)
// %rbx == src_i
// %r12 == &amp; RT.province.zstring
// %r13 == src.end()
// %r14 == &amp; RT
// %r15 == &amp; T1.province.zstring

// Local variables
// Range for local variables used in loop: 0x100 = 256 bytes = 4-5 data cache
//                                                             lines
// (includes 0x18+0x8+0x28 = 0x48 = 52 bytes = 1-2 extra cache lines for
//                                                 padding and locals unused
//                                                 in the loop)
// Local variable offsets (hexadecimal) from %rsp:
//  0 TEMP0 (saves %rcx across call to memcmp)
//(18 bytes of padding and other locals)
// 20 src
//   20 begin()
//   28 end()
//   30 cap_end() Pointer to byte following the reserved capacity
//( 8 bytes of padding)
// 40 res
//   40 begin()
//   48 end()
//   50 cap_end() Pointer to byte following the reserved capacity
//(28 bytes of padding and other locals)
// 80 l_us lambda capture by copy (copy-constructed once, before loop body,
//                                 destructor called after loop body)
//   80 str_buff Pointer to string value (null-terminated)
//   88 string length (not counting null)
//   90 Union
//      zstring 16-byte buffer for null-terminated strings of length &lt; 16
//      capacity 8-byte size of heap buffer for strings of length &gt;= 16
// a0 T1 Rvalue ppair constructed in lambda via aggregate initialization
//   a0 province
//     a0 str_buff Pointer to string value (null-terminated)
//     a8 string length (not counting null)
//     b0 Union
//      zstring 16-byte buffer for null-terminated strings of length &lt; 16
//      capacity 8-byte size of heap buffer for strings of length &gt;= 16
//   c0 value
// d0 RT move-constructed parameter (type oppair) t of
//      opt_back_emplace_iterator::operator=(T&amp;&amp; t)
//   d0 province
//     d0 str_buff Pointer to string value (null-terminated)
//     d8 string length (not counting null)
//     e0 Union
//      zstring 16-byte buffer for null-terminated strings of length &lt; 16
//      capacity 8-byte size of heap buffer for strings of length &gt;= 16
//   f0 value
//   f8 has_value

// Heap references (arrays for src and res, strings longer than 15 chars)
// src and res: Single pass in monotonically-increasing order (data prefetching
//   should work)
// strings: single memcpy call for every string &gt; 15 chars (most likely two
//   distinct heap locations = 2 data cache lines)
//          When us.len &gt; 15:
//            single memcmp call for every string of same length as us
//            (most likely two distinct heap locations = 2 data cache lines)

// Body: Build optional&lt;pair&lt;string,int&gt;&gt; and append to res (value is ensured)
// T1 = (src_i-&gt;province, src_i-&gt;value ^ 2)
&lt;+600&gt;:	mov    0x20(%rbx),%ebp           %ebp &lt;- src_i-&gt;value
&lt;+603&gt;:	mov    %r15,0xa0(%rsp)           T1.province.addr &lt;- &amp;T1.province.zstring
&lt;+611&gt;:	lea    0xa0(%rsp),%rdi           %rdi &lt;- &amp;T1.province
&lt;+619&gt;:	mov    (%rbx),%rsi               %rsi &lt;- &amp;src_i-&gt;province.zstring
&lt;+622&gt;:	imul   %ebp,%ebp                 %ebp &lt;- src_i-&gt;value ^ 2
&lt;+625&gt;:	lea    (%rsi,%rcx,1),%rdx        %rdx &lt;- &amp;src_i-&gt;province.zstring[len+1]
&lt;+629&gt;:	callq  0x401550 std::string::_M_construct&lt;char*&gt;(char*, char*, std::forward_iterator_tag) HEAP STRING REFERENCE (for string &gt; 15 chars)
&lt;+634&gt;:	mov    0xa0(%rsp),%rax           %rax &lt;- &amp; T1.province.zstring
&lt;+642&gt;:	mov    %ebp,0xc0(%rsp)           T1.value &lt;- src_i-&gt;value ^ 2
// RT = (T1.province, src_i-&gt;value ^ 2, true)
&lt;+649&gt;:	mov    %r12,0xd0(%rsp)           RT.province.str_buff &lt;- &amp; RT.province.zstring
&lt;+657&gt;:	cmp    %r15,%rax                 Was T1.str_buff changed?
&lt;+660&gt;:	je     0x401238 &lt;main()+1256&gt;    Jump if no change (taken when string is of length &lt; 16)
/*
  Direct move of T1.province.str_buff to
  RT.province.str_buff. T1.province has no destructor called. RT is
  directly initialized and T1 "never really existed" This approach
  allows RT.province to be initialized without any heap accesses
 */
&lt;+666&gt;:	mov    %rax,0xd0(%rsp)           RT.province.str_buff &lt;- T1.province.str_buff
&lt;+674&gt;:	mov    0xb0(%rsp),%rax
&lt;+682&gt;:	mov    %rax,0xe0(%rsp)           RT.province.capacity &lt;- T1.province.capacity
&lt;+690&gt;:	mov    0xa8(%rsp),%rax           %rax &lt;- T1.province.len
&lt;+698&gt;:	mov    %ebp,0xf0(%rsp)           RT.value &lt;- src_i-&gt;value ^ 2
&lt;+705&gt;:	movb   $0x1,0xf8(%rsp)           RT.optional &lt;- true
&lt;+713&gt;:	mov    %rax,0xd8(%rsp)           RT.province.len &lt;- T1.province.len
// *res_i = (RT.province, RT.value)
// For rest of loop body, %rax == res_i
&lt;+721&gt;:	mov    0x48(%rsp),%rax           %rax &lt;- res.end()
&lt;+726&gt;:	cmp    0x50(%rsp),%rax           res.cap_end() ==? &amp;res.end()
&lt;+731&gt;:	je     0x401295 &lt;main()+1349&gt;    Jump if equal; extend res (never taken, sufficient space reserved)
&lt;+737&gt;:	test   %rax,%rax                 
&lt;+740&gt;:	je     0x40108f &lt;main()+831&gt;     Jump if res.end() == nullptr (never taken, space has already been reserved)
&lt;+742&gt;:	lea    0x10(%rax),%rdx           %rdx &lt;- &amp;res.end().zstring
&lt;+746&gt;:	mov    %rdx,(%rax)               res.end()-&gt;str_buff &lt;- &amp;res.end().zstring

&lt;+749&gt;:	mov    0xd0(%rsp),%rdx           %rdx &lt;- RT.province.str_buff
&lt;+757&gt;:	cmp    %r12,%rdx                 Is RT buffer local?
&lt;+760&gt;:	je     0x401260 &lt;main()+1296&gt;    if == ... (string length &lt; 16---Move the 16 bytes from RT.province.zstring
                                         to res_i-&gt;province.zstring
                                         else move-assign the heap buffer res_i-&gt;province &lt;- RT
/* 
   Unlike RT &lt;- T1 assignment above, res_i-&gt;province &lt;- RT.province is
   an actual move assignment.  RT.str_buff is copied to
   res_i-&gt;province.str_buff (transferring ownership of the heap
   object) and later (see below) RT.province will be reset to an empty
   string and still later have its destructor called.  The destructor
   will not reference the heap because RT.province is a null string.
*/
  &lt;+766&gt;:	mov    %rdx,(%rax)               res_i-&gt;province.str_buff &lt;- RT.province.str_buff
  &lt;+769&gt;:	mov    0xe0(%rsp),%rdx           
  &lt;+777&gt;:	mov    %rdx,0x10(%rax)           res_i-&gt;province.capacity &lt;- RT.province.capacity
                                           // endif
&lt;+781&gt;:	mov    0xd8(%rsp),%rdx
&lt;+789&gt;:	mov    %rdx,0x8(%rax)            res.end()-&gt;province.len &lt;- RT.province.len
&lt;+793&gt;:	mov    0xf0(%rsp),%edx           %edx &lt;- RT.value
// RT.province &lt;- "" due to move assignment to res.end()-&gt;province
&lt;+800&gt;:	mov    %r12,0xd0(%rsp)           RT.province.str_addr &lt;- &amp; RT.province.zstring
&lt;+808&gt;:	movq   $0x0,0xd8(%rsp)           RT.province.strlen &lt;- 0
&lt;+820&gt;:	movb   $0x0,0xe0(%rsp)           RT.province.zstring &lt;- '\000'
&lt;+828&gt;:	mov    %edx,0x20(%rax)           res_i-&gt;value &lt;- RT.value
// res_i++
&lt;+831&gt;:	addq   $0x28,0x48(%rsp)          res_i++
&lt;+837&gt;:	cmpb   $0x0,0xf8(%rsp)           (! RT.has_value())?  VESTIGIAL---never true
&lt;+845&gt;:	je     0x4010b1 &lt;main()+865&gt;     Branch if no value---never taken
// RT.province.~string()
&lt;+847&gt;:	mov    0xd0(%rsp),%rdi           %rdi &lt;- RT.province.str_addr
&lt;+855&gt;:	cmp    %r12,%rdi                 &amp;RT.province.zstring ==? RT.province.str_buff (always true due to move assignment)
&lt;+858&gt;:	je     0x4010b1 &lt;main()+865&gt;     Always taken (due to move assignment)
 &lt;+860&gt;:	callq  0x400c00 &lt;_ZdlPv@plt&gt; operator delete()@plt Delete non-local string buffer for RT.province (never necessary)

// Increment counter and check for loop completion
// %rbx      == src_i
// %r13      == src.end()

// Increment and check src_i
&lt;+865&gt;:	add    $0x28,%rbx                src_i++
&lt;+869&gt;:	cmp    %rbx,%r13                 src_i ==? src.end()
&lt;+872&gt;:	je     0x401100 &lt;main()+944&gt;     Cleanup: l_us.~string()

// Process *src_i: Check src_i-&gt;province ==? l_us
&lt;+874&gt;:	mov    0x8(%rbx),%rcx            %rcx &lt;- src_i-&gt;province.len()
&lt;+878&gt;:	cmp    0x88(%rsp),%rcx           l_us.len() ==? src_i-&gt;province.len()
&lt;+886&gt;:	jne    0x400fa8 &lt;main()+600&gt;     =&gt; Not equal: Build result
&lt;+892&gt;:	test   %rcx,%rcx                 src_i-&gt;province ==? "" (and also l_us, because equal lengths)
&lt;+895&gt;:	je     0x4010b1 &lt;main()+865&gt;     =&gt; Equal null: Move to next (never taken)
&lt;+897&gt;:	mov    0x80(%rsp),%rsi           %rsi &lt;- &amp;l_us.zstring
&lt;+905&gt;:	mov    (%rbx),%rdi               %rdi &lt;- &amp;src_i-&gt;province.zstring
&lt;+908&gt;:	mov    %rcx,%rdx                 %rdx &lt;- src_i-&gt;province.len()
&lt;+911&gt;:	mov    %rcx,(%rsp)               TEMP0 &lt;- %rcx
&lt;+915&gt;:	callq  0x400cd0 &lt;memcmp@plt&gt;     Compare string contents HEAP STRING REFERENCE (for string &gt; 15 chars)
&lt;+920&gt;:	test   %eax,%eax                 (%eax != 0 =&gt; not equal)
&lt;+922&gt;:	mov    (%rsp),%rcx               %rcx &lt;- TEMP0
&lt;+926&gt;:	jne    0x400fa8 &lt;main()+600&gt;     Not equal: Build result

// src_i-&gt;province == l_us: increment and check src_i, loop to process new value
&lt;+932&gt;:	add    $0x28,%rbx                src_i++
&lt;+936&gt;:	cmp    %rbx,%r13                 src_i ==? src.end()
&lt;+939&gt;:	jne    0x4010ba &lt;main()+874&gt;     Not equal =&gt; Go to next
[/code]

The above is the main loop body.  We're not done though, as there are these two external branch targets 317 bytes later:

[code gutter="false"]
// RT.province.zstring &lt;- T1.province.zstring (Short string optimization)
&lt;+1256&gt;:	mov    0xb0(%rsp),%rax           %rax &lt;- zstring[0:7]
&lt;+1264&gt;:	mov    0xb8(%rsp),%rdx           %rdx &lt;- zstring[8:15]
&lt;+1272&gt;:	mov    %rax,0xe0(%rsp)           RT.province.zstring &lt;- (%rax, %rdx)
&lt;+1280&gt;:	mov    %rdx,0xe8(%rsp)
&lt;+1288&gt;:	jmpq   0x401002 &lt;main()+690&gt;

// Align next branch target
&lt;+1293&gt;:	nopl   (%rax)

// res_i-&gt;province.zstring &lt;- RT.province.zstring (Short string optimization)
&lt;+1296&gt;:	mov    0xe0(%rsp),%rsi           %rsi &lt;- zstring[0:7]
&lt;+1304&gt;:	mov    0xe8(%rsp),%rdi           %rdi &lt;- zstring[8:15]
&lt;+1312&gt;:	mov    %rsi,0x10(%rax)           res_i-&gt;province.zstring &lt;- (%rsi, %rdi)
&lt;+1316&gt;:	mov    %rdi,0x18(%rax)
&lt;+1320&gt;:	jmpq   0x40105d &lt;main()+781&gt;
</code></pre>
</div>

<p>Whoa, that’s a lot more code than <a href="/2017/05/02/performance-of-the-stl-idiom-for-list-comprehension-introduction/">the basic C++ version generated</a>! Just over 3.4 times more code, in fact. As well as 2.3 times more stack storage for local variables and temporaries.</p>

<p>The increased stack storage indicates the key contributor to the increased code size:  There are a lot more local variables and temporaries in this version. Given that these locals typically include a <code class="highlighter-rouge">std::string</code> member, there is a lot of code managing that complex type. The basic version uses one 4-byte temporary for the result of the squared integer value, while the <code class="highlighter-rouge">transform</code> idiom generates one 8-byte temporary to save a register and 128 bytes of temporary values (<code class="highlighter-rouge">l_us</code>, <code class="highlighter-rouge">T1</code>, and <code class="highlighter-rouge">RT</code>).</p>

<p>The temporaries increase register pressure, as well. In the basic version, <code class="highlighter-rouge">src_i</code> and <code class="highlighter-rouge">res_i</code>, the iterators for <code class="highlighter-rouge">src</code> and <code class="highlighter-rouge">res</code>, are both in registers, as is <code class="highlighter-rouge">src.end()</code>, used in the loop termination test.  The <code class="highlighter-rouge">transform</code> version uses all of these but also dedicates registers for temporaries <code class="highlighter-rouge">RT</code> (the result of the lambda, of type <code class="highlighter-rouge">optional&lt;pair&gt;</code>) and <code class="highlighter-rouge">T1</code> (the temporary <code class="highlighter-rouge">ppair</code> created to pass to the <code class="highlighter-rouge">RT</code> constructor). In fact, the register pressure is strong enough that the register holding iterator <code class="highlighter-rouge">res_i</code> is refreshed from local storage in Line 721.</p>

<p>Temporary <code class="highlighter-rouge">T1</code> seems to enjoy the odd <a href="https://www.youtube.com/watch?v=MlrsqGal64w">semi-existence of Eric the Half-a-Bee</a>, constructed in Lines <code class="highlighter-rouge">600–642</code> but never in fact destroyed. Instead its values are simply moved whole-cloth into temporary result <code class="highlighter-rouge">RT</code> in Lines <code class="highlighter-rouge">649–713</code> and the branch target Lines <code class="highlighter-rouge">1256–1288</code>, without any destructor code generated.  This is distinctly different from <code class="highlighter-rouge">RT</code>, which is move-constructed into the element of <code class="highlighter-rouge">res</code> referenced by iterator <code class="highlighter-rouge">res_i</code> (held in register <code class="highlighter-rouge">%rax</code>) in Lines <code class="highlighter-rouge">721–828</code>.  In this sequence, Lines <code class="highlighter-rouge">800–828</code> implement the assignment of the null string to <code class="highlighter-rouge">RT.province</code>, as required by the standard.  Later, Lines <code class="highlighter-rouge">847–860</code> implement the destructor <code class="highlighter-rouge">RT.province.~string()</code>.  Neither of these steps, the assignment of the null string nor the destructor, is generated for <code class="highlighter-rouge">T1</code>.</p>

<p>For the potentially slowest operations, references to the heap causing cache misses, the two implementations are identical, making the same sequence of references to the elements of <code class="highlighter-rouge">src</code> and <code class="highlighter-rouge">res</code>.</p>

<p>The compiler has done a marvellous job of collapsing function calls.  The <code class="highlighter-rouge">transform</code> idiom uses only a single stack frame, the same as the basic code. Techniques of function inlining have successfully collapsed all the layers of function call imposed by the Standard Library’s abstractions.  This is no small feat: In the unoptimized (<code class="highlighter-rouge">-O0</code>) version of the machine code, the deepest call stack has eight levels, as reported by gdb.</p>

<h2>The costs of so many temporaries and parameters</h2>

<p>But the many layers of function abstraction obstruct the optimizer in another way: Each layer requires that a parameter be passed, whether by move- or copy-construction or by reference.  I considered this problem when comparing <a href="/2017/03/07/three-idioms-for-appending-values-a-damaging-decision/">different idioms for appending values</a>.  Consider the steps initiated by the body of the loop in <code class="highlighter-rouge">std::transform</code>, the following expression:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="o">*</span><span class="n">res_i</span> <span class="o">=</span> <span class="n">lambda</span><span class="p">(</span><span class="o">*</span><span class="n">src_i</span><span class="p">);</span> <span class="c1">// Using my names for the iterators
</span></code></pre>
</div>

<p>where <code class="highlighter-rouge">__result</code> is an iterator of type <code class="highlighter-rouge">opt_back_insert_iterator&lt;vector&lt;optional&lt;ppair&gt;&gt;&gt;</code>.</p>

<p>The lambda function terminates with the statement</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">return</span> <span class="n">oppair</span><span class="p">(</span><span class="n">ppair</span><span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">})</span>
</code></pre>
</div>

<p>to compute the result of <code class="highlighter-rouge">lambda(*src_i)</code>.</p>

<p>In <code class="highlighter-rouge">libstdc++</code> 6.2, the <code class="highlighter-rouge">return&lt;</code> statement initiates the following cascade of function calls:</p>

<ol>
  <li>The temporary <code class="highlighter-rouge">ppair</code> is <a href="http://en.cppreference.com/w/cpp/language/aggregate_initialization">aggregate-initialized</a>.  This in turn requires
copy-constructing the <code class="highlighter-rouge">std::string</code> and <code class="highlighter-rouge">int</code> components of the <code class="highlighter-rouge">ppair</code> at <code class="highlighter-rouge">*src_i</code>. Move constructors cannot be used because the value in <code class="highlighter-rouge">src</code> must not be
modified.</li>
  <li>The temporary <code class="highlighter-rouge">oppair</code> (of <code class="highlighter-rouge">optional&lt;ppair&gt;</code> type) is explicitly constructed using the Standard Library
<a href="http://en.cppreference.com/w/cpp/utility/optional/optional"><code class="highlighter-rouge">optional&lt;ppair&gt;::optional(ppair&amp;&amp; p)</code></a>.</li>
  <li>The function <code class="highlighter-rouge">opt_back_insert_iterator&lt;vector&lt;optional&lt;ppair&gt;&gt;&gt;::operator=(optional&lt;ppair&gt;&amp;&amp;t)</code> is invoked.</li>
  <li>This invokes the move constructor <code class="highlighter-rouge">optional&lt;ppair&gt;::optional(optional&amp;&amp;)</code> to construct the parameter.</li>
  <li>The <code class="highlighter-rouge">optional</code> move constructor in turn invokes the move constructor for <code class="highlighter-rouge">std::string</code> and copies the <code class="highlighter-rouge">int</code> value.</li>
  <li>The rvalue has its member function <code class="highlighter-rouge">optional&lt;pair&gt;::value()</code> invoked, which returns an rvalue reference to the <code class="highlighter-rouge">pair</code> constructed in the first step.</li>
  <li>The constructed rvalue reference is move-constructed into the parameter for <code class="highlighter-rouge">vector&lt;ppair&gt;::push_back(ppair&amp;&amp;)</code>.</li>
  <li><code class="highlighter-rouge">vector&lt;ppair&gt;::push_back(ppair&amp;&amp;)</code> simply calls
<code class="highlighter-rouge">vector&lt;ppair&gt;::emplace_back(ppair&amp;&amp;)</code>, which constructs the <code class="highlighter-rouge">ppair</code> value
in the element at <code class="highlighter-rouge">res.end()</code>, incrementing the end marker.</li>
</ol>

<p>Ultimately, all this machinery is invoked to do a near-trivial operation: Copy a <code class="highlighter-rouge">std::string</code> and an <code class="highlighter-rouge">int</code> from an element of <code class="highlighter-rouge">src</code> to an element of <code class="highlighter-rouge">res</code>.  The core C++ language and the Standard Library introduce many features in hope of allowing the programmer to write at the abstract level and have the code compile to the simple level.  But given all the above layers, I am unsurprised that gcc 6.2 could not eliminate them all. The optimizer successfully compressed the hierarchy function calls into a single stack frame but could not compress the hierarchy of constructors, leaving residue like the unnecessary <code class="highlighter-rouge">T1</code> temporary. How much did this extra code affected performance?  In the next post, I will begin presenting microbenchmarks comparing the basic and the <code class="highlighter-rouge">transform</code> implementations of the filter-and-transform algorithm.</p>


</div>




<div id="disqus_thread"></div>
<script>

var disqus_config = function () {
this.page.url = "http://kirkpatricktech.com/2017/05/03/analysis-of-code-generated-from-the-transform-idiom/";
//this.page.identifier = "/2017/05/03/analysis-of-code-generated-from-the-transform-idiom";
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://kirkpatricktech-com.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </div>

  </body>
</html>
