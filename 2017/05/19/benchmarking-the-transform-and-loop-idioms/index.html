<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Benchmarking the transform and loop idioms &middot; All my marbles in one place
    
  </title>

  <!-- Google Analytics -->
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66576928-4', 'auto');
  ga('send', 'pageview');
  </script>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-0c layout-reverse">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          All my marbles in one place
        </a>
      </h1>
      <p class="lead">A blog about course design, data display, C++, and Python.  Yes, these are related, at least as I see them.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
      
        
          
            <a class="sidebar-nav-item" href="/credits/">Credits</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

    
        <div class="sidebar-tags">
        Tags:<br/>
        
	   
	    <a href="/tag/C++/">C++</a>,
	  
        
	  	    
            <a href="/tag/Python/">Python</a>
          
        
	</div>
      

    </nav>

    <p>&copy; 2017. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Benchmarking the transform and loop idioms</h1>
  <span class="post-date">19 May 2017
  
    <span class="tag-block">Tags: 
    
      
      <a href="/tag/C++">C++</a>
      
    
    </span>
  
  </span>
  
  <p>The last posts compared the machine code generated by <code>transform</code> and the equivalent idiom using an explicit <code>for</code> loop and <code>if</code> statement.  The <code>transform</code> idiom generated more intermediate copies of the <code>std::string</code> member than the loop.</p>

<p>As I noted in the posts, code differences indicate the degree to which the optimizer was able to reduce the standard library abstractions to the essential underlying algorithm but only approximately predict differences in performance. The performance effects must ultimately be assessed by benchmarks.</p>

<p>There are a wide range of methods and levels at which benchmarks might be used to compare these two idioms.  I will focus on microbenchmarking, timing short code sequences under several conditions of underlying data type and order.  This does not predict the effect of choosing these idioms in a full application, where their contribution will typically be small.  But it does provide insight into the effectiveness of the different machine code sequences that the optimizer generated for each idiom.</p>

<p>I emphasize that the most important outcome of these benchmarks is the relative performance of the various constructs, not their absolute values.  Your performance will certainly vary. See the Caveats and Appendix sections for further discussion of the limits of these results.</p>

<h2>Conditions</h2>

<p>I ran initial tests exploring the effect of various factors on performance and settled on the following factors as most important:</p>

<ol>
<li><p>Type of the elements: The samples that I presented in earlier posts used elements that were <code>std::pair</code>, with the first part, the <code>std::string</code>, used for the filter. The <code>libstdc++</code> implementation of a <code>string</code> is complex, offering different performance profiles for short strings (15 character or less) versus long strings and for operations that only use the string length versus those that require accessing the string body.</p>

<p>The second member, the <code>int</code>, generated simple code that had no performance impact.</p>

To sample the performance range of string data, I ran microbenchmarks with three different string representations as the first member of the pair:

<ul>
<li><b>Short:</b> <code>std::string</code> values exactly 3 characters long. Strings of this length are stored in the string handle and can only be distinguished by  comparing the actual string bodies.
</li>
<li><b>Long:</b> <code>std::string</code> values exactly 26 characters long. Strings of this length are stored in heap-allocated storage and can only be distinguished by comparing the actual string bodies.
</li>
<li><b>Unique:</b> Null-terminated <code>char const *</code> values that are uniquely identified by their address. Copies, moves, and comparisons of these values are all trivial, requiring only manipulation of eight-byte pointers.
</li>
</ul>
<p>
There are further possibilities, such as short <code>std::string</code> values that can be distinguished simply by their differing lengths, as well as far more complicated types, but the above three represent an initial sample of three distinct performance profiles.</p>
</li>
<li><p>Using <code>vector::push_back()</code> versus using <code>vector::emplace_back()</code>: Both the loop and the <code>transform</code> idiom can be written to push a previously-constructed temporary value onto the end of the <code>vector</code> (<code>push_back()</code>) or to construct a value directly in uninitialized storage at the <code>vector</code>'s end (<code>emplace_back()</code>). Typically, <code>emplace_back()</code> is faster, as it does not generate a temporary value.</p>
<p>
The sample idioms that I presented in previous posts differed in this.
The <code>transform</code> idiom used <code>push_back()</code>. I verified that <code>gcc</code> 6.2 generated the same machine code when the idiom was written using <code>emplace_back()</code>. By contrast, I presented the loop code using <code>emplace_back()</code> and the code generated for that was simpler than when <code>push_back()</code> was used. In this post, I microbenchmark both versions of both idioms.</p>
</li>
<li><p>Proportion of elements copied: The source vector contains pairs whose first member value is one of two string values of the given representation. One of those values is the one to be filtered out, while the other value is the one to be copied. The benchmarks were run with five different source data sets, with different fractions of values to be copied: 0%, 25%, 50%, 75%, and 100%.   The string comparison is performed for every element in the source vector, but only the copied proportion of the elements are appended to the result vector.</p>
</li>
<li><p>Order of the data elements: Both idioms are at heart a branch located inside a loop. For such algorithms, the order of the elements affects the branch prediction rate. For example, if 50% of the values are copied, then 50% of the branches will be taken and 50% will not. If the successful branches are all collected together at the start or end of the source vector, the hardware branch predictor will perfectly predict the branch (with a small number of failed predictions at the transition), whereas if the copied and not-copied elements are randomly mingled, the predictor will consistently fail.  The benchmarks were run with the five data sets presented in random order and in sorted order.</p>
</li>
</ol>

<h2>Method</h2>

<p>I chose the <a href="http://nonius.io">Nonius C++ microbenchmarking framework</a>, due to its strong statistical design.  The two idioms were placed in functions called by the framework. Each idiom was written in both <code>push_back()</code> and <code>emplace_back()</code> versions:</p>

<h3><code>str_loop_emplace</code>: Basic loop using <code>emplace_back()</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">str_loop_emplace</span> <span class="p">(</span><span class="n">plist</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span> <span class="p">(</span> <span class="o">!</span> <span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">exclude</span><span class="p">)</span>
      <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<h3><code>str_loop_push</code>: Basic loop using <code>push_back()</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">str_loop_push</span> <span class="p">(</span><span class="n">plist</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span> <span class="p">(</span> <span class="o">!</span> <span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">exclude</span><span class="p">)</span>
      <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ppair</span><span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">});</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<h3><code>str_option_emp</code>: <code>transform</code> idiom using an output iterator calling <code>emplace_back()</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">str_option_emp</span><span class="p">(</span><span class="n">plist</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span> <span class="p">(</span> <span class="o">!</span> <span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">opt_back_emplacer</span><span class="p">(</span><span class="n">res</span><span class="p">),</span>
    <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">exclude</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">oppair</span><span class="p">();</span>
      <span class="k">else</span>
        <span class="k">return</span> <span class="n">oppair</span><span class="p">(</span><span class="n">ppair</span><span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">});</span>
    <span class="p">}</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h3><code>str_option</code>: <code>transform</code> idiom using an output iterator calling <code>push_back()</code></h3>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">str_option</span><span class="p">(</span><span class="n">plist</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span> <span class="p">(</span> <span class="o">!</span> <span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">opt_back_inserter</span><span class="p">(</span><span class="n">res</span><span class="p">),</span>
    <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">exclude</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">oppair</span><span class="p">();</span>
      <span class="k">else</span>
        <span class="k">return</span> <span class="n">oppair</span><span class="p">(</span><span class="n">ppair</span><span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">});</span>
    <span class="p">}</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>There are two blemishes in the above code that I only noticed after gathering all the data. Neither of them substantively affects the benchmark results:</p>

<ol>
<li>The initial <code>assert()</code> calls, checking that the result vector is empty, were a legacy of initial testing that the benchmarking code worked as expected. Left in the benchmark, they add a small amount of unnecessary computation. This will have no effect on the relative performance, as the same cost is paid for every benchmark and the dominant cost is the processing of the 50,000 vector elements. Nonetheless, in future runs, the <code>assert</code> calls should be deleted.
</li>
<li>The two <code>transform</code> benchmark functions, <code>str_option</code> and <code>str_option_emp</code>, declare a result but do not return one.  Accepting such functions without warning is a "feechure" of gcc. The result actually returned from these function is gibberish (by chance, it is the square of the second member for the last copied element). The only purpose of the results of the benchmark functions is to force the optimizer to call the functions; the return value is never used. Reviewing the generated code, the function logic is generated and the function called, so the declared return value serves its purpose despite being gibberish and the performance results are unaffected. Nonetheless, in future runs, these two functions should have explicit <code>return</code> statements.
</li>
</ol>

<p>Reviewing the generated code, the two implementations of the <code>transform</code> idiom produced identical code, both calling <code>emplace_back()</code>.  This arose because the <code>libstdc++</code> implementation of <code>push_back()</code> includes an overload that simply maps to <code>emplace_back()</code> and this overload was the one resolved for the <code>opt_back_insert_iterator()</code> used as the output iterator for <code>str_option</code>. In the benchmark results, the two <code>transform</code> implementations performed identically.</p>

<p>Refactoring the code into functions changed the generated code in small ways from the code discussed in the two prior posts: The <code>res</code> vector is now a by-reference parameter rather than a local variable, while the <code>src</code> vector and <code>exclude</code> constant are now global rather than local.  The actual changes to the generated code are modest; the performance results for these functions should correlate well with the performance of the code described earlier.</p>

<p>The source array always had 50,000 elements.  Each benchmark was run 10,000 times and their arithmetic mean is reported.  For every reported result, the size of the 95% confidence interval reported by Nonius was less than 3% of the mean.   Full details of the benchmark conditions are given in the Appendix.</p>

<h2>Overview of results</h2>

<p>I’ll start with an overview of the benchmark results:</p>

<p><img src="https://ted376.files.wordpress.com/2017/05/overview_plot.png" alt="overview_plot" width="577" height="662" class="alignnone size-full wp-image-7077" /></p>

<p>Each dot represents the mean of 10,000 samples.  The number of dots varies by condition because I ran the benchmark varying numbers of times, from one run for each condition with unique strings, to five runs for the sorted datasets of short strings.</p>

<p>The largest effect is due to string type (comparing rows of plots): Using the short strings (middle row) as a reference point, long strings (top row) are roughly twice as slow and unique strings (bottom row) are twice as fast.</p>

<p>The next largest effect is proportion of items actually copied (order of colours within each lane; see legend correlating colours to proportion). Within each string type, copying more values into the result vector requires more time. This is hardly surprising but it does emphasize the cost of moving data, even for simple data types such as short strings (32 bytes to copy in a 64-bit implementation) and <code>char const *</code> (8 bytes to copy in a 64-bit implementation).</p>

<p>Using <code>vector::emplace_back()</code> versus <code>vector::push_back()</code> had a substantial effect for the loop (leftmost lane is loop with <code>emplace_back()</code>, second lane from left is loop with <code>push_back()</code>) but as expected had no effect for <code>std::transform()</code> (rightmost lane is <code>transform</code> with <code>emplace_back()</code>, second lane from right is <code>transform</code> with <code>push_back()</code>).</p>

<p>Finally, consider the question motivating this analysis:  How did the performance of <code>transform</code> compare with that of the loop? I will take the <code>emplace_back()</code> implementation as representative of the loop’s performance (it is trivially easy to use <code>emplace_back()</code> in the loop, as well as widely-recommended—for example, see Item 42 of Scott Meyers’s <a href="http://www.aristeia.com/books.html"><i>Effective Modern C++</i></a>). The choice is arbitrary for <code>transform</code> given the two implementations’ equivalent performance and identical code, so I will take the <code>push_back()</code> implementation.  These choices produce a comparison between the leftmost lane of the plots (the loop with <code>emplace_back()</code>) and the second lane from the right (<code>transform</code> with <code>push_back()</code>).</p>

<p>Within each subplot, the loop is faster than <code>transform</code> for the cases where at least some elements are copied to the result vector. The two idioms offer equivalent performance for the case where no data elements were copied.</p>

<p>Finally, I note some anomalies in the plots:</p>

<ul>
<li>For the case of 75% copied of sorted data (upper right subplot), three of the implementations have a single run that was anomalously slow. I speculate that the conditions in my machine were substantively different during those runs---perhaps some background OS housekeeping process was running. The other two runs for this case also seem unexpectedly high, the only cases in all plots where algorithms ran more slowly on sorted data. I am not aware what the actual cause was and it does not seem to have arisen during the <code>str_loop_emplace</code> benchmark, which was run first.
</li>
<li>For the loop processing unsorted short strings and unique strings (the left lane of the two bottom left plots), the performance is not predicted by the proportion of copies. I will discuss this in detail below.
</li>
</ul>

<p>For the rest of the post, I will focus on the <code>emplace_back()</code> version of the loop and the <code>push_back()</code> version of the idiom.</p>

<h2>Comparison of long <code>std::string</code></h2>

<p>The results for long strings are the most straightforward to interpret:</p>

<p><img src="https://ted376.files.wordpress.com/2017/05/long_plot.png" alt="long_plot" width="495" height="369" class="alignnone size-full wp-image-7079" /></p>

<p>The long strings are two 26-character strings, differing only in the last character. As such, they require a utility routine call to compare the string bodies, which are stored in the heap and likely cause cache misses. Move constructions and assignments remain cheap, because the heap pointer can simply be moved to the target, which accepts ownership of the heap object. By contrast, copy constructions and assignments are expensive, requiring a heap allocation for the copy of the string body, again incurring cache misses.</p>

<p>Given the high cost of string operations, the dominant factor in performance is the number of items to copy, which predicts the order of results: More copies mean slower performance.</p>

<p>We see a mild effect of branch misprediction in the case of 50% copied: The loop processes sorted input (second lane from left) about .25 ms faster than unsorted input (leftmost lane).  This effect is barely present for <code>transform</code>.</p>

<p>The loop is faster than <code>transform</code> directly proportional to the number of copies.  The two idioms are most different for 100% and 75% copies, while they are equivalent for 0%.  For long strings, the slower performance of <code>transform</code> appears to be due to extra temporary values constructed when copying into the result vector.</p>

<p>I consider the results for <code>transform</code> on the 75% copied case (top of two right lanes) more tentative than the others, as they are anomalous in two ways. First, the three means for the sorted data are not clustered, with one 75% mean instead clustered with the two means for the 100% copied data.  Second, all three means for the <code>transform</code> of sorted data are higher than the corresponding means for unsorted data.  This is the only instance of processing sorted data more slowly than unsorted and I cannot think of a reasonable explanation.  Due to these anomalies, I accord these data points less confidence than the others.</p>

<h2>Comparison of short <code>std::string</code></h2>

<p>The results for short strings are more complex:</p>

<p><img src="https://ted376.files.wordpress.com/2017/05/short_plot.png" alt="short_plot" width="495" height="369" class="alignnone size-full wp-image-7078" /></p>

<p>The short strings are both 3 characters long, differing in their final character.  All operations can be performed by access to the string handle (<code>libstdc++</code> stores string bodies of less than 16 characters in the handle rather than the heap), avoiding heap accesses and highly reducing the likelihood of cache misses. As noted in the overview, the improvement is clear: Short strings are about twice as fast as long strings.</p>

<p>The reduced effect of string copying allows other effects to appear, particularly the effect of branch misprediction. As the misprediction effect is most noticeable for the loop, I will begin with the more straightforward <code>transform</code> results (the two right lanes).</p>

<p>The dominant factor in performance of <code>transform</code> on short strings is the percent of values copied to the result. On sorted data, the means are directly proportional to this percentage. For unsorted data, branch misprediction effects appear.  For the 100% and 0% copied cases, branch prediction should be perfect irrespective of data order, as the branch will succeed or fail for every element. This is confirmed by the means for these cases, which are the same for unsorted and sorted data sets.</p>

<p>However, for the 50% copied case, branch prediction will nearly always be wrong for unsorted data but essentially perfect for sorted data, only mispredicting at the transition from excluded to included values.  The means for 50% copies show a substantial improvement for sorted data.</p>

<p>For the data sets that have 75% and 25% of their values copied, there will be two contending effects.  For both cases, branch prediction will be modestly effective even for unsorted data, as occasional runs of inclusion or exclusion in the data will support successful prediction. However, the 25% data set requires substantially fewer copies than the 75% data set, making it faster.  These effects are apparent in the means: <code>transform</code> is substantially faster on sorted data than unsorted for the 25% case, where branch misprediction is a large contributor, but the idiom is only slightly faster for sorted data in the 75% case, where the cost of copying values dominates.</p>

<p>Branch misprediction has a much larger effect on the loop (two left lanes).  When this idiom processes unsorted data (leftmost lane), the proportion of values copied no longer predicts the relative performance of the data sets. The two fastest unsorted data sets are those for which branch prediction is perfect, with 0% and 100% copied. All datasets for which branch prediction is imperfect, the 25%, 50%, and 75%, are slower. Indeed, the 50% and 75% cases have almost the same performance, due to near-total branch misprediction (in the 50% case) having almost as much effect as half again more string copies (in the 75% case).</p>

<p>When the loop runs on sorted data (second lane from left), branch prediction is perfect, leaving only the proportion of copies as a factor.  The more copies required, the slower the processing.</p>

<p>Finally, comparing the results for the two idioms, <code>transform</code> is 25–50% slower than the loop, with the gap proportional to the number of values copied.  For 0% copied, the two idioms are equivalent.</p>

<h2>Comparison of unique <code>char const *</code> strings</h2>

<p>The unique <code>char const *</code> strings are trivially fast to copy or compare, requiring only manipulation of 8-byte pointers. Consequently, the influence of dataset order is even stronger for these strings:</p>

<p><img src="https://ted376.files.wordpress.com/2017/05/unique_plot.png" alt="unique_plot" width="501" height="369" class="alignnone size-full wp-image-7080" /></p>

<p>For both idioms, order once again has no effect on performance for datasets where 0% or 100% of the elements are copied, due to perfect branch prediction.  For <code>transform</code> (right two lanes), the 50% copied case suffered the greatest loss due to branch misprediction, with the unsorted data about a third slower than the sorted data. Misprediction had no discernible effect on the 75% copied data and only a slight effect on the 25% copied data.  For <code>transform</code>, the relative ordering of the means was always determined by the proportion of copies.</p>

<p>For the loop, branch misprediction had a larger effect (left two lanes). As with the short string case, the order of the results for the unsorted data (leftmost lane) corresponded to the number of correctly-predicted branches, not the number of copies. The datasets with perfect prediction (0% and 100% copied) were fastest, while the unpredictable dataset (50% copied) was slowest, with the partially-predictable datasets (25% and 75%) in between. Within each level of branch predictability, the number of copies determined the relative ranking.</p>

<p>For the sorted case, the loop performance was directly proportional to the number of copies made, as branch prediction was near-perfect for every dataset.</p>

<p>Comparing the two idioms, <code>transform</code> was surprisingly slow, from 2.5 times to the same rate. Once again, the number of extraneous temporaries made by <code>transform</code> seems to be the source of the difference, as the two algorithms take identical times for datasets where no elements are copied.</p>

<h2>Caveats</h2>

<p>These results reflect a small number of samples (only a single sample in the case of the unique strings) on a single OS/machine configuration (see Appendix for details).  For the cases where I have multiple samples, they seem reliable, with the lone exception of the sorted data set of long strings with 75% copies for <code>transform</code>. My confidence is increased by the consistency between these results, my analysis of the machine code, and well-understood theories of performance on modern processors.  Nonetheless, the numbers are more suggestive than definitive. I would like to run more tests in future but I have put enough time into this analysis already and want to post it.  These results at least tell a consistent, believable story.</p>

<h2>Conclusion</h2>

<p>Is the <code>transform</code> idiom a useful alternative to the loop?  I confess that the analysis of the code and benchmarks is making me question the <code>transform</code> idiom’s utility.  The loop idiom is immediately understandable to anyone who’s programmed in any language, robust, and has a more direct expression of the underlying algorithm that permits the compiler to generate code without extraneous temporaries.  More familiar <em>and</em> faster: a hard pair to beat.</p>

<p>The only advantages of the <code>transform</code> idiom, such as they may be, include increased familiarity with the standard algorithm family.  I still believe that there are many cases where a standard algorithm is preferable to a hand-crafted alternative.  I don’t want to write my own sort or even my own unique-values algorithm, thank you.  But the filter-and-transform embodied by the basic Python list comprehension maps cleanly to a range <code>for</code> loop and <code>if</code> statement.  Introducing a <code>std::optional</code> value and an optional-aware output iterator just to use <code>transform</code> now seems too clever by half. In my own code, I expect I’ll stick with a <code>for</code> loop in this case.</p>

<p>In future posts, I’ll extend this analysis to a few more cases but my focus will likely shift to the impact of temporary values on execution speed.  The biggest lesson of these benchmarks is how much impact extraneous temporaries have.</p>

<h2>Appendix: Detailed method description</h2>

<p>This appendix presents the technical specifics of the benchmarks.</p>

<h3>Nonius calls</h3>

<p>The code for running the <code>str_loop_emplace</code> benchmark:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">using</span> <span class="n">ppair</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">oppair</span> <span class="o">=</span> <span class="n">optional</span><span class="o">&lt;</span><span class="n">ppair</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">plist</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ppair</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">plist</span> <span class="n">src</span> <span class="p">{};</span>
<span class="n">plist</span> <span class="n">res</span> <span class="p">{};</span> <span class="c1">// NOT USED IN BENCHMARKS
</span>
<span class="kt">int</span> <span class="n">included</span> <span class="p">{};</span>
<span class="n">string</span> <span class="n">exclude</span> <span class="p">{};</span>

<span class="n">bool</span> <span class="nf">check</span><span class="p">(</span><span class="k">const</span> <span class="n">plist</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="cp">#if PRINT_SIZE
</span>  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"LEFT "</span> <span class="o">&lt;&lt;</span> <span class="n">LEFT</span> <span class="o">&lt;&lt;</span> <span class="s">" res.size() "</span> <span class="o">&lt;&lt;</span> <span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="cp">#endif
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">included</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"res.size() "</span> <span class="o">&lt;&lt;</span> <span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", included "</span> <span class="o">&lt;&lt;</span> <span class="n">included</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">:</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">included</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef DO_LOOP_EMPLACE
</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">str_loop_emplace</span> <span class="p">(</span><span class="n">plist</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span> <span class="p">(</span> <span class="o">!</span> <span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">BY</span> <span class="n">p</span> <span class="o">:</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">exclude</span><span class="p">)</span>
      <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">NONIUS_BENCHMARK</span><span class="p">(</span><span class="s">"str_loop_emplace"</span><span class="p">,</span> <span class="p">[]</span> <span class="p">(</span><span class="n">nonius</span><span class="o">::</span><span class="n">chronometer</span> <span class="n">meter</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">plist</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">meter</span><span class="p">.</span><span class="n">runs</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">r</span> <span class="o">:</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">r</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">meter</span><span class="p">.</span><span class="n">measure</span><span class="p">(</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">str_loop_emplace</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]);}</span> <span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">r</span> <span class="o">:</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">check</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="p">});</span>

<span class="cp">#endif
</span></code></pre>
</div>

<p>The code for the other three benchmarks was the same, substituting the appropriate function from the beginning of this post for <code>str_loop_emplace</code>.</p>

<p>Vector <code>src</code> was loaded before any benchmarks were run and re-used for every benchmark. The code is given below.</p>

<p>The <code>NONIUS_BENCHMARK</code> function may execute a given benchmark several times if the measured clock resolution is insufficiently accurate to measure just one execution.  The number of runs is available via <code>meter.runs()</code>.  To ensure the executions are independent, a separate result vector is created for each, represented as vector <code>res</code>, local to the function that ran the benchmark. Each benchmark was passed its own <code>res[i]</code> to receive the result.</p>

<p>The global <code>res</code> vector declared in Line 6 is a remnant of earlier versions and was not used in these benchmarks. The local <code>res</code> vector of vectors defined in Line 36 was used instead.</p>

<p>Several preprocessing macros determined the final code:</p>

<dl>
<dt><code>PRINT_SIZE</code></dt><dd><code>1</code> when testing the benchmark code. <code>0</code> for actual benchmarks.</dd>
<dt><code>BY</code></dt><dd>Set to <code>&amp;</code> for actual benchmarks.  The functions given in the main post present the code after this macro had been expanded to an ampersand. In future, will be set to empty to test performance impact of pass-by-value.</dd>
<dt><code>DO_LOOP_EMPLACE</code></dt><dd>Set to <code>1</code> when running actual benchmarks. In testing, can be set to <code>0</code> to not compile a benchmark.</dd>
<dt><code>NONIUS_BENCHMARK</code></dt><dd>Standard macro for defining a Nonius benchmark harness.</dd>
</dl>

<h3>Initialization of <code>src</code> vector</h3>

<p>The source vector was initialized and Nonius called by the following code:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span><span class="p">,</span> <span class="mi">13</span><span class="o">&gt;</span> <span class="n">regions</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">"British Columbia"</span><span class="p">,</span>
  <span class="s">"Alberta"</span><span class="p">,</span>
  <span class="s">"Saskatchewan"</span><span class="p">,</span>
  <span class="s">"Manitoba"</span><span class="p">,</span>
  <span class="s">"Ontario"</span><span class="p">,</span>
  <span class="s">"Quebec"</span><span class="p">,</span>
  <span class="s">"Newfoundland and Labrador"</span><span class="p">,</span>
  <span class="s">"New Brunswick"</span><span class="p">,</span>
  <span class="s">"Prince Edward Island"</span><span class="p">,</span>
  <span class="s">"Nova Scotia"</span><span class="p">,</span>
  <span class="s">"Yukon"</span><span class="p">,</span>
  <span class="s">"Northwest Territories"</span><span class="p">,</span>
  <span class="s">"Nunuvat"</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">long_regs</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">"Newfoundland and Labrador0"</span><span class="p">,</span>
  <span class="s">"Newfoundland and Labrador1"</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">short_regs</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">"NL0"</span><span class="p">,</span>
  <span class="s">"NL1"</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">set_copied</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">proportion</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;&amp;</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">included</span><span class="p">,</span> <span class="n">plist</span><span class="o">&amp;</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">v</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">proportion</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ppair</span><span class="p">{</span><span class="n">regs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">value</span><span class="p">});</span>
    <span class="n">included</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ppair</span><span class="p">{</span><span class="n">regs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">});</span>      
<span class="p">}</span>

<span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">SeedType</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">rbits</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RBits</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
  <span class="c1">// Range of random #s includes both bounds: [0, 99]
</span>  <span class="n">MRandInt</span> <span class="n">rnd</span><span class="p">(</span><span class="n">rbits</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="mi">99</span><span class="p">);</span>
  
<span class="cp">#if LEFT == 1
</span>  <span class="n">exclude</span> <span class="o">=</span> <span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="cp">#elif LEFT == 2 || LEFT == 6 || LEFT == 7 || LEFT == 10 || LEFT == 11 
</span>  <span class="n">exclude</span> <span class="o">=</span> <span class="n">long_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="cp">#elif LEFT == 3 || LEFT == 4 || LEFT == 5 || LEFT == 8 || LEFT == 9
</span>  <span class="n">exclude</span> <span class="o">=</span> <span class="n">short_regs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="cp">#else
</span>  <span class="n">static_assert</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="s">"Missing case in init "</span> <span class="err">##</span> <span class="n">LEFT</span><span class="p">);</span>
<span class="cp">#endif
</span>
  <span class="n">src</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rnd</span><span class="p">();</span>
    <span class="cp">#if LEFT == 1
</span>    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">v</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">src</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ppair</span><span class="p">{</span><span class="n">regions</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">i</span><span class="p">});</span>
      <span class="n">included</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">src</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ppair</span><span class="p">{</span><span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">});</span>
    <span class="cp">#elif LEFT == 2
</span>    <span class="n">set_copied</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">long_regs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">included</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
    <span class="cp">#elif LEFT == 3
</span>    <span class="n">set_copied</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">short_regs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">included</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
    <span class="cp">#elif LEFT == 4
</span>    <span class="n">set_copied</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">short_regs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">included</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
    <span class="cp">#elif LEFT == 5
</span>    <span class="n">set_copied</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">short_regs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">included</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
    <span class="cp">#elif LEFT == 6
</span>    <span class="n">set_copied</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">long_regs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">included</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
    <span class="cp">#elif LEFT == 7
</span>    <span class="n">set_copied</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">long_regs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">included</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
    <span class="cp">#elif LEFT == 8
</span>    <span class="n">set_copied</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="n">short_regs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">included</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
    <span class="cp">#elif LEFT == 9
</span>    <span class="n">set_copied</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="n">short_regs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">included</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
    <span class="cp">#elif LEFT == 10
</span>    <span class="n">set_copied</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="n">long_regs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">included</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
    <span class="cp">#elif LEFT == 11
</span>    <span class="n">set_copied</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="n">long_regs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">included</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
    <span class="cp">#else
</span>    <span class="n">static_assert</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="s">"src proportions undefined"</span><span class="p">);</span>
    <span class="cp">#endif
</span>  <span class="p">}</span>

  <span class="cp">#if SORTED == 1
</span>  <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="cp">#elif SORTED == 2
</span>  <span class="n">std</span><span class="o">::</span><span class="n">shuffle</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="o">*</span><span class="n">rbits</span><span class="p">);</span>
  <span class="cp">#endif
</span>  <span class="cm">/* 
  // Following just for ensuring correctness
  for (const auto&amp; p : src)
    std::cerr &lt;&lt; '(' &lt;&lt; p.first &lt;&lt; ", " &lt;&lt; p.second &lt;&lt; ")\n";
  std::cerr &lt;&lt; std::endl;
  */</span> 
  <span class="n">res</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">size</span> <span class="o">=</span> <span class="n">SIZE</span><span class="p">;</span>
  <span class="n">init</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">MRandInt</span><span class="o">::</span><span class="n">getSeed</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">nonius</span><span class="o">::</span><span class="n">main</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The following macros determined the compiled code:</p>

<dl>
<dt><code>LEFT</code></dt><dd>Selected the combination of string type and proportion of copies for a given run. Ranged from 1 to 11.</dd>
<dt><code>SIZE</code></dt><dd>Number of entries in <code>src</code> vector. Set to 50,000 for all benchmarks.</dd>
<dt><code>SORTED</code></dt><dd>Defined whether the <code>src</code> vector was in random order (<code>SORTED==0</code>), sorted (<code>SORTED==1</code>), or shuffled (<code>SORTED==2</code>).  Both the random and sorted cases were used in benchmarks; the shuffled case was not used.</dd>
</dl>

<p>Class <code>MRandInt</code> generates random integers over a specified inclusive range.  For these benchmarks, it generated values between 0 and 99 (inclusive), which were used to randomly select whether the included or excluded value.  A different random seed was used for every run. The proportions of values copied consequently changed from run to run but all were close to the target.</p>

<p>I made a slight variation of the main Nonius function to allow me to call <code>init</code> before calling <code>nonius::main</code>.</p>

<h3>Run conditions</h3>

<p>All benchmarks were run on a guest Ubuntu 16.04 system, running under VirtualBox 5.0.20r106931, on a host Mac OS 10.12.4.  The hardware was a MacBook Pro with a 2.4 GHz Intel Core i5 and 8 GB memory.</p>

<p>No other user-facing applications were running on either the guest or host system (though both had ample numbers of background daemons running) and the host machine had its network turned off.</p>

<p>Each run specified a Nonius sample size of 10,000 and the default bootstrap resample size of 100,000.</p>

<p>For every benchmark, the 95% confidence interval returned by the bootstrap was less than or equal to 3% of the sample mean.</p>


</div>




    </div>

  </body>
</html>
